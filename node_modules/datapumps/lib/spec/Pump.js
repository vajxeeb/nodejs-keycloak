(function() {
  var Buffer, Promise, Pump, sinon;

  require('should');

  sinon = require('sinon');

  Promise = require('bluebird');

  Buffer = require('../Buffer');

  Pump = require('../Pump');

  describe('Pump', function() {
    describe('#start()', function() {
      it('should pump content from source to output buffer', function(done) {
        var buffer, pump;
        buffer = new Buffer({
          content: ['foo', 'bar', 'test', 'content']
        });
        buffer.seal();
        pump = new Pump;
        pump.from(buffer);
        sinon.spy(pump.buffer(), 'write');
        pump.on('end', function() {
          pump.buffer().write.getCall(0).args[0].should.equal('foo');
          pump.buffer().write.getCall(1).args[0].should.equal('bar');
          pump.buffer().write.getCall(2).args[0].should.equal('test');
          pump.buffer().write.getCall(3).args[0].should.equal('content');
          return done();
        });
        pump.start();
        return pump.buffer().readAsync().then((function(_this) {
          return function() {
            return pump.buffer().readAsync();
          };
        })(this)).then((function(_this) {
          return function() {
            return pump.buffer().readAsync();
          };
        })(this)).then((function(_this) {
          return function() {
            return pump.buffer().readAsync();
          };
        })(this));
      });
      it('should not be possible to change source buffer after start', function() {
        var pump, source;
        source = new Buffer;
        source.readAsync = function() {
          return Promise.resolve();
        };
        pump = new Pump;
        return (function() {
          return pump.from(source).start().from(source);
        }).should["throw"]('Cannot change source buffer after pumping has been started');
      });
      it('should not be possible to change output buffer after start', function() {
        var pump, source;
        source = new Buffer;
        source.readAsync = function() {
          return Promise.resolve();
        };
        pump = new Pump;
        return (function() {
          return pump.from(source).start().buffers({
            output: source
          });
        }).should["throw"]('Cannot change output buffers after pumping has been started');
      });
      it('should write target buffer when source is readable', function(done) {
        var buffer1, pump;
        buffer1 = new Buffer({
          content: ['test']
        });
        pump = new Pump;
        pump.buffer().writeAsync = sinon.spy(function(data) {
          data.should.equal("test");
          return done();
        });
        return pump.from(buffer1).start();
      });
      it('should create error buffer on start if not set', function() {
        var pump;
        (pump = new Pump).from(new Buffer).start();
        return pump.errorBuffer().should.not.be["null"];
      });
      it('should write errors to the error buffer', function(done) {
        var pump;
        return (pump = new Pump).from(['testData']).errorBuffer(new Buffer).process(function() {
          return Promise.reject('test');
        }).run().then(function() {
          pump.errorBuffer().getContent().length.should.equal(1);
          pump.errorBuffer().getContent()[0].should.eql({
            error: 'test',
            pump: null
          });
          return done();
        });
      });
      return it('should write error when process does not return a Promise', function(done) {
        var pump;
        return (pump = new Pump).from(['x']).process(function(data) {
          return data;
        }).run().then(function() {
          pump.errorBuffer().getContent().length.should.equal(1);
          return done();
        });
      });
    });
    it('should seal output buffers when source buffer ends', function(done) {
      var pump, source;
      source = new Buffer;
      pump = new Pump;
      pump.from(source);
      sinon.spy(pump.buffer(), 'seal');
      pump.start();
      source.seal();
      return setTimeout(function() {
        pump.buffer().seal.calledOnce.should.be["true"];
        return done();
      }, 1);
    });
    it('should emit end event when all output buffers ended', function() {
      var endSpy, pump, source;
      source = new Buffer;
      pump = new Pump;
      pump.from(source);
      endSpy = sinon.spy();
      pump.on('end', endSpy);
      source.seal();
      pump.start();
      endSpy.calledOnce.should.be["true"];
      return pump.isEnded().should.be["true"];
    });
    it('should be able to transform the data', function(done) {
      var buffer, pump;
      buffer = new Buffer({
        content: ['foo', 'bar']
      });
      pump = new Pump;
      pump.from(buffer).process(function(data) {
        return this.buffer().writeAsync(data + '!');
      });
      sinon.spy(pump.buffer(), 'write');
      pump.on('end', function() {
        pump.buffer().write.getCall(0).args[0].should.equal('foo!');
        pump.buffer().write.getCall(1).args[0].should.equal('bar!');
        return done();
      });
      buffer.seal();
      pump.start();
      return pump.buffer().readAsync().then(function() {
        return pump.buffer().readAsync();
      });
    });
    describe('#mixin()', function() {
      var testMixin;
      testMixin = function(target) {
        return target.foo = 'bar';
      };
      it('should add mixins from array to the pump', function() {
        var pump, testMixin2;
        pump = new Pump;
        testMixin2 = function(target) {
          return target.foo2 = 'bar2';
        };
        pump.mixin([testMixin, testMixin2]);
        pump.foo.should.equal('bar');
        return pump.foo2.should.equal('bar2');
      });
      return it('should be able to add a single mixin', function() {
        var pump;
        pump = new Pump;
        pump.mixin(testMixin);
        return pump.foo.should.equal('bar');
      });
    });
    describe('#from()', function() {
      it('should throw error when argument is not a buffer, array or stream', function() {
        var pump;
        pump = new Pump;
        return (function() {
          return pump.from('test');
        }).should["throw"]('Argument must be datapumps.Buffer or stream');
      });
      return it('should convert array to a sealed datapumps.Buffer', function() {
        var pump;
        (pump = new Pump).from(['foo', 'bar']);
        pump.from().isSealed().should.be["true"];
        return pump.from().getContent().should.eql(['foo', 'bar']);
      });
    });
    describe('#pause()', function() {
      return it('should return a promise that resolves when the pump paused', function(done) {
        var pump;
        pump = new Pump;
        pump.from(new Buffer);
        pump.from().write('test');
        pump.from().write('test');
        pump.buffer().on('write', function() {
          return pump.pause().then(function() {
            pump.from().getContent().length.should.equal(1);
            pump._state.should.equal = Pump.PAUSED;
            return done();
          });
        });
        return pump.start();
      });
    });
    describe('#resume()', function() {
      return it('should resume the pump when its paused', function() {
        var pump;
        pump = new Pump;
        pump.from(new Buffer);
        pump.start();
        pump.pause();
        sinon.spy(pump, '_pump');
        pump.resume();
        return pump._pump.calledOnce.should.be["true"];
      });
    });
    return describe('#copy(data, buffers = null)', function() {
      it('should write data to the default buffer if buffers parameter is not given', function(done) {
        var pump;
        pump = new Pump();
        return pump.copy('test').then(function() {
          pump.buffer().getContent().should.eql(['test']);
          return done();
        });
      });
      it('should write data to the given buffer', function(done) {
        var pump;
        pump = new Pump();
        return pump.copy('test', 'output').then(function() {
          pump.buffer().getContent().should.eql(['test']);
          return done();
        });
      });
      return it('should write data to the given buffers if multiple buffers are given', function(done) {
        var pump;
        pump = new Pump();
        pump.buffers({
          out1: new Buffer,
          out2: new Buffer
        });
        return pump.copy('test', ['out1', 'out2']).then(function() {
          pump.buffer('out1').getContent().should.eql(['test']);
          pump.buffer('out2').getContent().should.eql(['test']);
          return done();
        });
      });
    });
  });

}).call(this);
