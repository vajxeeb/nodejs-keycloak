(function() {
  var Buffer, Group, Promise, Pump, sinon,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  require('should');

  sinon = require('sinon');

  Group = require('../Group');

  Buffer = require('../Buffer');

  Pump = require('../Pump');

  Promise = require('bluebird');

  describe('Group', function() {
    describe('#addPump(name)', function() {
      it('should add a pump to the group', function() {
        var group;
        group = new Group;
        group.addPump('test');
        return group.pump('test').should.not.be.empty;
      });
      it('should throw error when pump already exists', function() {
        var group;
        group = new Group;
        group.addPump('test');
        return (function() {
          return group.addPump('test');
        }).should["throw"]('Pump already exists');
      });
      it('should set the id of the added pump when group has id', function() {
        var group, pump;
        group = new Group;
        pump = new Pump;
        group.id('group').addPump('test', pump);
        return pump.id().should.equal('group/test');
      });
      return it('should set the id of the added pump when group does not have id', function() {
        var group, pump;
        group = new Group;
        pump = new Pump;
        group.addPump('test', pump);
        return pump.id().should.equal('test');
      });
    });
    describe('#start()', function() {
      it('should start all pumps', function() {
        var group;
        group = new Group;
        group.addPump('foo').from(new Buffer);
        group.addPump('bar').from(group.pump('foo').buffer());
        sinon.spy(group.pump('foo'), 'start');
        sinon.spy(group.pump('bar'), 'start');
        group.start();
        group.pump('foo').start.calledOnce.should.be["true"];
        return group.pump('bar').start.calledOnce.should.be["true"];
      });
      return it('should set error buffer for all pumps', function() {
        var group;
        group = new Group;
        group.addPump('foo').from(new Buffer);
        group.addPump('bar').from(group.pump('foo').buffer());
        group.start();
        group.errorBuffer().should.equal(group.pump('foo').errorBuffer());
        return group.errorBuffer().should.equal(group.pump('bar').errorBuffer());
      });
    });
    it('should emit end event when all pumps ended', function(done) {
      var group, source;
      group = new Group;
      source = new Buffer;
      group.addPump('foo').from(source);
      group.addPump('bar').from(group.pump('foo').buffer());
      group.on('end', function() {
        return done();
      });
      group.start();
      return source.seal();
    });
    describe('#whenFinished()', function() {
      return it('should return a promise that fulfills when all pumps ended', function(done) {
        var group, source;
        group = new Group;
        source = new Buffer;
        group.addPump('foo').from(source);
        group.addPump('bar').from(group.pump('foo').buffer());
        group.whenFinished().then(function() {
          return done();
        });
        group.start();
        return source.seal();
      });
    });
    describe('#expose(exposedName, bufferPath)', function() {
      it('should expose a buffer of a pump as its own buffer', function() {
        var group;
        group = new Group;
        group.addPump('test');
        group.expose('foo', 'test/output');
        return group.buffer('foo').should.equal(group.pump('test').buffer('output'));
      });
      return it('should expose the default buffer of pump if not given in path', function() {
        var group;
        group = new Group;
        group.addPump('test');
        group.expose('foo', 'test');
        return group.buffer('foo').should.equal(group.pump('test').buffer('output'));
      });
    });
    describe('#inputPump(pumpName)', function() {
      return it('should throw error when nonexistent name is set', function() {
        var group;
        group = new Group;
        return (function() {
          return group.inputPump('test');
        }).should["throw"]('Pump test does not exist');
      });
    });
    describe('#from(buffer)', function() {
      it('should call .from on pump configured in .inputPump', function() {
        var buffer, group;
        group = new Group;
        group.addInputPump('test');
        buffer = new Buffer;
        sinon.spy(group.pump('test'), 'from');
        group.from(buffer);
        group.pump('test').from.calledOnce.should.be["true"];
        return group.pump('test').from.getCall(0).args[0].should.equal(buffer);
      });
      return it('should throw error when input pump is not configured', function() {
        var group;
        group = new Group;
        return (function() {
          return group.from('foo');
        }).should["throw"]('Input pump is not set, use .inputPump to set it');
      });
    });
    it('should emit error event when errorBuffer is full', function(done) {
      var buffer, group;
      group = new Group;
      buffer = new Buffer({
        size: 1
      });
      group.errorBuffer(buffer).start();
      group.on('error', function() {
        return done();
      });
      return buffer.write('test');
    });
    describe('#pause()', function() {
      return it('should pause all pumps that has started state', function() {
        var group;
        group = new Group;
        group.addPump('test').from(new Buffer);
        group.addPump('test2').from(group.buffer('test'));
        group.addPump('test3').from(group.buffer('test2'));
        group.run = function() {
          return this.runPumps(['test', 'test2']);
        };
        group.start();
        group.pause();
        group.pump('test').isPaused().should.be["true"];
        group.pump('test2').isPaused().should.be["true"];
        return group.pump('test3').isStopped().should.be["true"];
      });
    });
    describe('#buffer(name)', function() {
      return it('should accept buffer path for name (i.e. pumpName/bufferName)', function() {
        var group;
        group = new Group;
        group.addPump('test');
        group.buffer('test/output').should.equal(group.pump('test').buffer('output'));
        return group.buffer('test').should.equal(group.pump('test').buffer());
      });
    });
    describe('#runPumps(pumpNames)', function() {
      return it('should return a promise that resolves when all pumps has been finished', function(done) {
        var group;
        group = new Group;
        group.addPump('test1').from(new Buffer);
        group.addPump('test2').from(group.buffer('test1'));
        group.addPump('test3').from(group.buffer('test2'));
        group.runPumps(['test1', 'test2']).then(function() {
          return done();
        });
        group.pump('test1').from().seal();
        return group.pump('test2').from().seal();
      });
    });
    describe('#id()', function() {
      return it('should update the ids of all pumps in the group', function() {
        var group;
        group = new Group;
        group.addPump('test');
        group.id('group');
        return group.pump('test').id().should.equal('group/test');
      });
    });
    return it('should abort pumps when error buffer is full', function(done) {
      var G1, G2, g2;
      G1 = (function(_super) {
        __extends(G1, _super);

        function G1(buffer) {
          G1.__super__.constructor.call(this);
          this.errorBuffer(buffer);
          this.addPump('p1').from([1, 2, 3]);
          this.addPump('p2').from(this.pump('p1')).process(function(item) {
            console.log(item);
            throw new Error(item);
            return Promise.resolve(console.log(item));
          });
        }

        return G1;

      })(Group);
      G2 = (function(_super) {
        __extends(G2, _super);

        function G2(buffer) {
          G2.__super__.constructor.call(this);
          this.errorBuffer(buffer);
          this.addPump('g1', new G1(buffer));
          this.addPump('x').from([1, 2, 3, 4, 5, 6, 7, 8, 9]).process(function() {
            return Promise.delay(300);
          });
        }

        return G2;

      })(Group);
      g2 = new G2(new Buffer({
        size: 1
      }));
      return g2.start().whenFinished()["catch"](function(err) {
        if (err.message === 'Pumping failed. See .errorBuffer() contents for error messages') {
          return done();
        }
      });
    });
  });

}).call(this);
