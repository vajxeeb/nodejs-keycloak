(function() {
  var Promise, RestMixin, restler, sinon;

  require('should');

  sinon = require('sinon');

  restler = require('restler');

  restler.get = sinon.stub().returns({
    on: function() {}
  });

  RestMixin = require('../RestMixin');

  Promise = require('bluebird');

  describe('RestMixin', function() {
    it('should wrap .get method of restler', function() {
      var target;
      target = {};
      RestMixin(target);
      target.get('foo');
      restler.get.calledOnce.should.be["true"];
      return restler.get.getCall(0).args[0].should.equal('foo');
    });
    it('should return a promise in the wrapped .get() method', function() {
      var target;
      target = {};
      RestMixin(target);
      return target.get('foo').should.be["instanceof"](Promise);
    });
    return describe('when using .fromRest() method', function() {
      var buffer, target;
      buffer = {
        writeArrayAsync: sinon.stub().returns(Promise.resolve()),
        seal: sinon.spy()
      };
      target = {
        from: function() {
          return buffer;
        },
        createBuffer: sinon.spy()
      };
      it('should be possible to fill input buffer', function(done) {
        buffer.writeArrayAsync.reset();
        buffer.seal.reset();
        RestMixin(target);
        target.fromRest({
          query: function() {
            return Promise.resolve(['foo', 'bar']);
          }
        });
        return process.nextTick(function() {
          buffer.writeArrayAsync.calledOnce.should.be["true"];
          buffer.seal.calledOnce.should.be["true"];
          return done();
        });
      });
      it('should be possible to map results with resultMapping key', function(done) {
        buffer.writeArrayAsync.reset();
        RestMixin(target);
        target.fromRest({
          query: function() {
            return Promise.resolve({
              items: ['foo', 'bar']
            });
          },
          resultMapping: function(result) {
            return result.items;
          }
        });
        return process.nextTick(function() {
          buffer.writeArrayAsync.calledOnce.should.be["true"];
          buffer.writeArrayAsync.getCall(0).args[0].should.eql(['foo', 'bar']);
          return done();
        });
      });
      return it('should be possible to use paginated REST service', function(done) {
        buffer.writeArrayAsync.reset();
        buffer.seal.reset();
        RestMixin(target);
        target.fromRest({
          query: function(nextPage) {
            return Promise.resolve(nextPage != null ? nextPage : ['foo', 'bar']);
          },
          nextPage: function(result) {
            if (result[0] !== 'next') {
              return ['next'];
            }
          }
        });
        return process.nextTick(function() {
          buffer.writeArrayAsync.calledTwice.should.be["true"];
          buffer.writeArrayAsync.getCall(0).args[0].should.eql(['foo', 'bar']);
          buffer.writeArrayAsync.getCall(1).args[0].should.eql(['next']);
          buffer.seal.calledOnce.should.be["true"];
          return done();
        });
      });
    });
  });

}).call(this);
