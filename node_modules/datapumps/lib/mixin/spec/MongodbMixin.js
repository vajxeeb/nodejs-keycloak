(function() {
  var MongodbMixin, Promise, mongo, sinon;

  require('should');

  sinon = require('sinon');

  MongodbMixin = require('../MongodbMixin');

  Promise = require('bluebird');

  mongo = Promise.promisifyAll(require('mongodb'));

  describe('MongodbMixin(db)', function() {
    it('should store db connection in target object', function() {
      var mixin, target;
      target = {};
      mixin = MongodbMixin({
        foo: 'bar'
      });
      mixin(target);
      return target._mongo.db.foo.should.equal('bar');
    });
    it('should connect to mongo if db is a string', function() {
      var mixin, replacedConnectAsync, target;
      replacedConnectAsync = mongo.MongoClient.connectAsync;
      mongo.MongoClient.connectAsync = sinon.stub().returns({
        then: function() {}
      });
      target = {};
      mixin = MongodbMixin('mongodb://127.0.0.1:27017/test');
      mixin(target);
      mongo.MongoClient.connectAsync.calledOnce.should.be["true"];
      return mongo.MongoClient.connectAsync = replacedConnectAsync;
    });
    it('should wrap collection methods into pump', function() {
      var mixin, mockCollection, mockDb, target;
      mockDb = {
        collection: function() {
          return mockCollection;
        }
      };
      mockCollection = {
        find: sinon.stub().returns({
          stream: function() {}
        })
      };
      target = {};
      mixin = MongodbMixin(mockDb);
      mixin(target);
      target.useCollection('foo');
      target.find('test');
      mockCollection.find.calledOnce.should.be["true"];
      return mockCollection.find.getCall(0).args[0].should.equal('test');
    });
    it('should defer .find() calls until connection established', function() {
      var connectResolveCallbacks, mixin, mockCollection, mockDb, replacedConnectAsync, streamSpy, target;
      connectResolveCallbacks = [];
      replacedConnectAsync = mongo.MongoClient.connectAsync;
      mongo.MongoClient.connectAsync = sinon.stub().returns({
        then: function(cb) {
          return connectResolveCallbacks.push(cb);
        },
        isPending: function() {
          return true;
        }
      });
      mockDb = {
        collection: function() {
          return mockCollection;
        }
      };
      mockCollection = {
        find: function() {
          return {
            stream: streamSpy
          };
        }
      };
      streamSpy = sinon.stub().returns({
        pipe: function() {}
      });
      target = {
        whenFinished: sinon.stub().returns({
          then: function() {}
        })
      };
      mixin = MongodbMixin('mongodb://127.0.0.1:27017/test');
      mixin(target);
      target.useCollection('foo');
      target.find('test');
      streamSpy.calledOnce.should.be["false"];
      connectResolveCallbacks.should.have.lengthOf(2);
      connectResolveCallbacks[0](mockDb);
      connectResolveCallbacks[1](mockDb);
      streamSpy.calledOnce.should.be["true"];
      return mongo.MongoClient.connectAsync = replacedConnectAsync;
    });
    return it('should defer .insert() calls until connection established', function() {
      var connectResolveCallbacks, mixin, mockCollection, mockDb, replacedConnectAsync, target;
      connectResolveCallbacks = [];
      replacedConnectAsync = mongo.MongoClient.connectAsync;
      mongo.MongoClient.connectAsync = sinon.stub().returns({
        then: function(cb) {
          return connectResolveCallbacks.push(cb);
        },
        isPending: function() {
          return true;
        }
      });
      mockDb = {
        collection: function() {
          return mockCollection;
        }
      };
      mockCollection = {
        insertAsync: sinon.stub().returns({
          then: function() {}
        })
      };
      target = {
        whenFinished: sinon.stub().returns({
          then: function() {}
        })
      };
      mixin = MongodbMixin('mongodb://127.0.0.1:27017/test');
      mixin(target);
      target.useCollection('foo');
      target.insert('test');
      mockCollection.insertAsync.calledOnce.should.be["false"];
      connectResolveCallbacks.should.have.lengthOf(2);
      connectResolveCallbacks[0](mockDb);
      connectResolveCallbacks[1](mockDb);
      mockCollection.insertAsync.calledOnce.should.be["true"];
      return mongo.MongoClient.connectAsync = replacedConnectAsync;
    });
  });

}).call(this);
